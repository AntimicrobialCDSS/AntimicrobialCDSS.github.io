// Function to search and sort data based on the input
function searchData() {
  const searchInput = document.getElementById('searchInput');
  const dropdown = document.getElementById('filterDropdown');
  const searchText = searchInput.value.trim().toLowerCase();
  
  // Check if the search text is empty
  if (searchText === '') {
    // Populate and sort the dropdown with the original data when the search text is blank
    populateDropdown(omData);
    sortDropdownByTerm();
  } else {
    // Split the search text by space to handle multiple search terms
    const searchTerms = searchText.split(' ');
    
    // Filter data based on search text and prioritize items with matches in Term1
    let filteredData = omData.map(item => {
      const Term1 = item.Term1 || item.Name;
      const contentTexts = (item.Contents || []).map(content => content.Text ? content.Text.toLowerCase() : '').filter(Boolean);
      let relevanceScore = 0;
      
      // Check for "Term1" and calculate relevance score
      if (Term1) {
        const termText = Term1.toLowerCase();
        if (searchTerms.includes(termText)) {
          relevanceScore += 1000; // Increase relevance score for exact term match significantly
        } else if (termText.includes(searchTerms)) {
          relevanceScore += 100; // Increase relevance score if search text is found in Term1
        }
      }
      
      // Check if any of the search terms are present in the item's contentTexts
      searchTerms.forEach(term => {
        contentTexts.forEach(text => {
          if (text.includes(term)) {
            relevanceScore += 1; // Increase relevance score if search term is found in contentTexts
          }
        });
      });
      
      return {
        ...item,
        relevanceScore, // Add relevance score to the item
      };
    })
    .filter(item => item.relevanceScore > 0) // Filter out items with relevance score of 0
    .sort((a, b) => {
      // Sort based on relevance score, descending
      if (a.relevanceScore !== b.relevanceScore) {
        return b.relevanceScore - a.relevanceScore;
      }
      // If relevance score is the same, sort alphabetically by Term1
      const aTerm1 = a.Term1 || a.Name;
      const bTerm1 = b.Term1 || b.Name;
      return aTerm1.localeCompare(bTerm1, undefined, { sensitivity: 'base' });
    });
    
    filteredData = filteredData.filter(item => !(item.Term1 || item.Name).toLowerCase().includes('index'));
    
    // Debugging: Log the filtered data
    console.log('Filtered Data:', filteredData);
    
    // Call the function to populate the dropdown with filtered and sorted data
    dropdown.innerHTML = '';
    filteredData.forEach(item => {
      const option = document.createElement('option');
      option.value = item.Name;
      option.textContent = item.Term1;
      dropdown.appendChild(option);
    });
    
    // Count the number of matches after the dropdown is populated
    const matchCount = dropdown.length;
    const firstLine = document.createElement('option');
    if (matchCount === 0) {
      // If there are no matches, create an option with red text
      firstLine.textContent = 'No Matches';
      firstLine.style.color = 'red'; // Set the text color to red
    } else {
      // If there are matches, create an option for the match count with green text
      firstLine.textContent = `Matches: ${matchCount}`;
      firstLine.style.color = 'green'; // Set the text color to green
    }
    firstLine.disabled = true;
    firstLine.selected = true;
    dropdown.insertBefore(firstLine, dropdown.firstChild);
  }
  
  // Scroll to the top of the dropdown
  dropdown.scrollTop = 0;
}
